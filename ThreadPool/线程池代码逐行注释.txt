#include<stdlib.h>   // malloc/free 等
#include<pthread.h>  // 线程库：pthread_create, mutex, cond 等
#include<stdio.h>    // printf
#include<string.h>   // memset, memcpy

// 宏：向链表头插入节点（生产者插入任务，或者线程链表管理）
#define LIST_INSERT(item, list) do { \
    if (list != NULL) list->prev = item; /* 原首节点prev指向新节点 */ \
    item->prev = NULL;                  /* 新节点prev为NULL */ \
    item->next = list;                  /* 新节点next指向原首节点 */ \
    list = item;                        /* 链表头指向新节点 */ \
} while(0)

// 宏：从链表中移除节点（消费者取任务）
#define LIST_REMOVE(item, list) do { \
    if ((item)->prev != NULL) (item)->prev->next = (item)->next; \
    if ((item)->next != NULL) (item)->next->prev = (item)->prev; \
    if ((list) == (item)) (list) = (item)->next; \
    (item)->prev = (item)->next = NULL; \
} while(0)


// 任务节点结构体
struct nTask{
    void (*task_func)(struct nTask *task); // 任务执行函数（消费者调用）
    void *user_data;                       // 任务参数

    struct nTask *prev; // 链表前驱
    struct nTask *next; // 链表后继
};

// 工作线程（消费者）
struct nWorker{
    pthread_t threadid;          // 线程ID
    int terminate;               // 终止标志
    struct nManager *manager;    // 所属线程池
    struct nWorker *prev;        // 链表前驱
    struct nWorker *next;        // 链表后继
};

// 线程池（管理者/缓冲区）
typedef struct nManager{
    struct nTask *tasks;       // 任务队列（缓冲区）
    struct nWorker *nWorkers;  // 工作线程队列

    pthread_mutex_t mutex;     // 互斥锁，保护任务队列（共享缓冲区）
    pthread_cond_t cond;       // 条件变量，通知消费者任务可用
}ThreadPool;


// 消费者线程函数
static void *nThreadPoolCallBack(void *arg){
    struct nWorker *worker = (struct nWorker*)arg; // 当前消费者线程
    printf("nThreadPoolCallback\n");

    while(1){ // 消费者循环
        pthread_mutex_lock(&worker->manager->mutex); // 锁住共享缓冲区（任务队列）

        // 缓冲区为空，消费者等待生产者生产任务
        while(worker->manager->tasks == NULL){
            if(worker->terminate) break; // 收到退出信号，结束线程
            pthread_cond_wait(&worker->manager->cond,&worker->manager->mutex); 
            // 原子释放锁并进入条件等待队列
        }

        if (worker->terminate){ // 消费者被终止
            pthread_mutex_unlock(&worker->manager->mutex); 
            break;
        }
        
        // 缓冲区非空，消费者取出任务（消费任务）
        struct nTask *task = worker->manager->tasks;
        LIST_REMOVE(task,worker->manager->tasks); // 从任务队列移除

        pthread_mutex_unlock(&worker->manager->mutex); // 解锁缓冲区

        task->task_func(task); // 执行任务
    }

    free(worker); // 线程退出，释放资源
}


// 创建线程池
int nThreadPoolCreate(ThreadPool *pool, int numWorkers){
    if(pool == NULL) return -1;
    if(numWorkers < 1) numWorkers = 1;

    memset(pool,0,sizeof(ThreadPool)); // 初始化线程池结构体

    // 初始化条件变量
    pthread_cond_t blank_cond = PTHREAD_COND_INITIALIZER; 
    memcpy(&pool->cond,&blank_cond,sizeof(pthread_cond_t));

    pthread_mutex_init(&pool->mutex,NULL); // 初始化互斥锁

    // 创建消费者线程
    int i = 0;
    for(i = 0; i < numWorkers; i++){
        struct nWorker *worker = (struct nWorker*)malloc(sizeof(struct nWorker));
        if(worker == NULL){
            perror("malloc");
            return -2;
        }

        memset(worker,0,sizeof(struct nWorker));
        worker->manager = pool;

        int ret = pthread_create(&worker->threadid,NULL,nThreadPoolCallBack,worker);
        if(ret){
            perror("pthread_create");
            free(worker);
            return -3;
        }

        LIST_INSERT(worker,pool->nWorkers); // 添加消费者到线程池管理链表
    }

    return 0;
}


// 销毁线程池
int nThreadPoolDestory(ThreadPool *pool, int nWorker){
    struct nWorker *worker = NULL;

    // 通知所有消费者线程退出
    for(worker = pool->nWorkers;worker != NULL;worker=worker->next){
        worker->terminate=1; // 设置终止标志
    }

    pthread_mutex_lock(&pool->mutex); 
    pthread_cond_broadcast(&pool->cond); // 唤醒所有消费者线程
    pthread_mutex_unlock(&pool->mutex);

    pool->nWorkers=NULL;
    pool->tasks=NULL;

    return 0;
}


// 生产者：提交任务到线程池（缓冲区）
int nThreadPoolPushTask(ThreadPool *pool, struct nTask *task){
    pthread_mutex_lock(&pool->mutex); // 锁住缓冲区

    LIST_INSERT(task,pool->tasks);    // 插入任务（生产）

    pthread_cond_signal(&pool->cond); // 唤醒一个消费者线程

    pthread_mutex_unlock(&pool->mutex); // 解锁缓冲区
}


#if 1
#define THREADPOOL_INIT_COUNT 20
#define TASK_INIT_SIZE 1000

// 示例任务函数（消费者执行）
void task_entry(struct nTask *task){
    int idx = *(int *)task->user_data;  // 读取任务参数
    printf("idx:%d\n",idx);

    free(task->user_data); // 释放参数内存
    free(task);            // 释放任务节点
}


int main(void)
{
    ThreadPool pool = {0};

    // 创建线程池（消费者线程初始化）
    nThreadPoolCreate(&pool,THREADPOOL_INIT_COUNT);
    printf("nThreadPoolCreate --- finish");

    int i = 0;

    // 生产者：创建任务并提交到线程池
    for(i=0;i<TASK_INIT_SIZE;i++)
    {
        struct nTask *task = (struct nTask *)malloc(sizeof(struct nTask));
        if(task == NULL){
            perror("malloc");
            exit(1);
        }

        memset(task,0,sizeof(struct nTask));

        task->task_func = task_entry;          // 设置任务执行函数
        task->user_data = malloc(sizeof(int)); // 分配参数内存
        *(int*)task->user_data = i;            // 设置任务参数

        nThreadPoolPushTask(&pool,task);       // 生产者提交任务
    }

    getchar(); // 阻塞主线程，防止程序立即退出
}   
#endif
