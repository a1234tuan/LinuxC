# 多线程并发锁项目

## 项目背景

在火车上买火车票，比如有10个窗口去抢座位号【火车票】

关于在座位号所对应的内容，就是共享资源

什么是多线程？什么是并发执行？

```c
#include<stdio.h>
#include<pthread.h>

#define THREAD_COUNT 10

void *thread_callback(void *arg){
    int *pcount = (int *)arg;
    int i = 0;

    while(i++ < 100000){
        (*pcount)++;
        usleep(1);
    }
}
int main(){
    //线程id    
    pthread_t threadid[THREAD_COUNT] = {0};
    //每个线程都有不一样的返回函数

    int i = 0;
    //创建十个线程【十个窗口】
    int count = 0;  //十个窗口共享计数资源
    for(i = 0;i<THREAD_COUNT;i++)
    {
        pthread_create(&threadid[i],NULL,thread_callback,&count); //&count是传入到void *arg中的
    }
    for(i =0;i < 100; i++){
        printf("count: %d\n",count);
        sleep(1);
    }
}

```

有没有什么办法能够将如下三条指令变为单指令，然后就可以不加锁了？①mov [count ] ,eax; ②inc eax; ③mov eax, [count];

## 用原子操作实现

在这个问题中方案选择的优先级：原子操作>自旋锁>互斥锁

```c

#include<stdio.h>
#include<pthread.h>

#define THREAD_COUNT 10

pthread_mutex_t mutex;//mutex锁
pthread_spinlock_t spinlock;

int inc(int *value, int add){
    int old;

    __asm__ volatile(
        "lock; xaddl %0, %1;"
        : "=r"(old), "+m"(*value)   // old 是输出，*value 既是输入又是输出
        : "0"(add)                  // "0" 表示和第 0 个输出操作数复用寄存器
        : "cc", "memory"
    );
    
    
    return old;
}

void *thread_callback(void *arg){
    int *pcount = (int *)arg;
    int i = 0;

    while(i++ < 100000){
#if 0
        (*pcount)++;//
#elif 0
        pthread_mutex_lock(&mutex);
        (*pcount)++;
        pthread_mutex_unlock(&mutex);

#elif 0
        pthread_spin_lock(&spinlock);
        (*pcount)++;
        pthread_spin_unlock(&spinlock);

#else
        inc(pcount,1);
#endif
        usleep(1);
    }
}
int main(){
    //线程id    
    pthread_t threadid[THREAD_COUNT] = {0};
    //每个线程都有不一样的返回函数

    //在线程创建之前初始化加锁
    pthread_mutex_init(&mutex,NULL);
    pthread_spin_init(&spinlock,PTHREAD_PROCESS_SHARED);
    int i = 0;
    //创建十个线程【十个窗口】
    int count = 0;  //十个窗口共享计数资源
    for(i = 0;i<THREAD_COUNT;i++)
    {
        pthread_create(&threadid[i],NULL,thread_callback,&count); //&count是传入到void *arg中的
    }
    for(i =0;i < 100; i++){
        printf("count: %d\n",count);
        sleep(1);
    }
}


```





课后练习题：了解CAS，并实现CAS



## 线程池的使用场景

### 一、为什么需要线程池？（动机）

#### 1.1 服务器和客户端的例子

想象一下：

- 一台服务器要同时处理成千上万个客户端的请求。
- 最直接的想法是：来一个客户端，就开一个线程来处理。

但是问题来了：

- 如果有 **10 万个客户端**，你就要开 **10 万个线程**。
- 每个线程大概要占 **8MB 内存**，这样内存早就爆了！

所以——**不能无限制地开线程**。

------

#### 1.2 为什么不用临时开线程？

开销大！

- **创建线程**需要向操作系统申请资源、分配栈空间。
- **销毁线程**又要释放资源。
   如果每个小任务都要这样做，浪费太多时间。

------

### 二、线程池能解决什么问题？

1. **控制线程数量**
   - 不会让系统里同时存在成千上万个线程。
   - 节省内存，保证系统稳定。
2. **线程复用**
   - 线程一旦创建好，就可以反复使用，不用每次开/关线程。
   - 降低了创建和销毁的开销。
3. **任务与执行分离**
   - 把“要做的事”（任务）和“谁来做”（线程）分开。
   - 程序更清晰，易于管理。

------

### 三、举个例子（生活类比）

#### 3.1 日志系统

- **写日志** = 把数据写进磁盘。
- 但“磁盘操作”比“内存操作”慢得多，写日志可能会让线程停下来等。
- 如果每个写日志都开一个线程，太浪费。
- 所以，把这些写日志的任务丢给线程池里的线程去执行，就高效多了。

------

#### 3.2 营业厅的柜员

想象一下银行营业厅：

- **办业务的人** = 任务
- **柜员** = 线程
- **排队等候区** = 任务队列

特点：

- 柜员不止一个（多个线程并行执行任务）。
- 办业务的人也不止一个（任务可能堆积，需要排队）。

------

### 四、管理问题（避免冲突）

1. **两个办业务的人，不能同时跑到同一个柜员那里**。
   - 否则就会乱套（相当于两个任务同时被一个线程执行）。
2. **两个柜员，不能同时给一个人办业务**。
   - 否则会重复、冲突（相当于多个线程抢同一个任务）。
3. **解决办法：公示牌**
   - 公示牌告诉大家：哪个柜员空闲、哪个客户正在被服务。
   - 在线程池中，这就对应于 **管理组件**（比如任务队列调度器、锁、同步机制）。



- **总结：线程池**由三部分组成：

1. 任务队列 
2. 线程池中的线程 
3. 管理机制

## 线程池的结构体定义



在写组件的时候：首先是定义它的属性、结构，接着就是定义方法

在写一个函数的定义的时候，主要包含三点：1.参数的校验 2.功能的实现 3.返回值

- 初始化部分：

```c
 pthread_cond_t blank_cond = PTHREAD_COND_INITALIZER;//定义一个空白的锁
    memcpy(&pool->cond,&blank_cond,sizeof(pthread_cond_t));//
```

>这段代码的逻辑是：
>
>1. 定义了一个临时的条件变量 `blank_cond`，并用 **宏初始化**；
>2. 用 `memcpy` 把 `blank_cond` 的内容，**拷贝**到 `pool->cond` 里。
>
>换句话说：
> 它其实就是在 **模拟动态初始化**，让 `pool->cond` 得到一个已经初始化好的条件变量。

​	推荐写法

​	如果你自己写代码，最好用 **标准方式**：

```
pthread_cond_init(&pool->cond, NULL);
```



**关于nThreadPoolCreate，做了那些事情？**

```c
int nThreadPoolCreate(ThreadPool *pool, int numWorkers){//numWorker就是多少种方法
    //参数的校验
    if(pool == NULL) return -1;
    if(nWorker < 1) nWorker = 1;
        //初始化
    pthread_cond_t blank_cond = PTHREAD_COND_INITALIZER;//定义一个空白的锁
    memcpy(&pool->cond,&blank_cond,sizeof(pthread_cond_t));

    //mutex初始化
    pthread_mutex_init(&pool->mutex,NULL);

    //关于nworkers初始化，比如初始化10个线程
    int i = 0;
    for(i = 0; i < numWorkers; i++){
        struct nWorker *worker = (struct nWorker*)malloc(sizeof(struct nWorker));
        if(worker == NULL){
            perror("malloc");
            return -2;
        }
        //每创建一个，加入到工作队列中
        memset(worker,0,sizeof(struct nWorker));
        worker->manager = pool;//

        pthread_create(worker->threadid,NULL,nThreadPoolCallBack,worker);
        if(ret){//如果创建失败
            perror("pthread_create");
            free(worker);;
            return -3;
        }
        //将创建好的添加到执行队列中去
        LIST_INSERT(worker,pool->nWorkers);

    }

    //success
    return 0;
    
```

1. 把它的参数进行校验

2. 对线程池管理的对象(nManager)的每一个域进行初始化

   >`struct nWorker *workers;`
   >
   >`pthread_mutex_t mutex;`
   >
   >`pthread_cond_t cond`;

3. 创建线程、传入回调函数作为参数，传入回调函数的意思，每个柜员的工作是一样的，都是去处理事务，但是执行的具体事务是不一样的，注意这个回调函数 != 任务，这个任务可以是十种业务中的一种



- **回调函数的实现逻辑**
  1. 判断任务队列里面有没有任务
  2. 从任务队列拿出一个任务
  3. 执行该任务



```c
//线程回调函数
static *nThreadPoolCallBack(void *arg){
    //线程就是一直在等待任务队列中是否有任务
    struct nWorkers *worker = (struct nWorkers*)arg;
    while(1){
        pthread_mutex_lock(&worker->manager->mutex);
        while(worker->manager->tasks == NULL){//营业员要去判断这个任务队列里面有没有任务，使用NULL来判断
            pthread_cond_wait(&worker->manager->cond,&worker->manager->mutex);//若没有任务，一直处于阻塞等待状态
        }
        //判断任务队列有任务，就要拿出任务出来,这里是把首节点拿出来
        struct nTask *task = worker->manager->tasks;
        LIST_REMOVE(task,worker->manager->tasks);

        pthread_mutex_unlock(&worker->manager->mutex);
        //任务开始执行：
        task->task_func(task->user_data);
    }

    free(worker);

    return ;

}
```



- **关于线程如何退出**

  引入int terminate，当terminate=1时候退出

  ```C
  //线程池销毁
  int nThreadPoolDestory(ThreadPool *pool, int nWorker){
      struct nWorker *worker = NULL;
  
      for(worker = pool->workers;worker != NULL;worker=worker->next){
          worker->terminate;
      }
      //做一个条件广播
      pthread_mutex_lock(&pool->mutex);//这把锁和在条件等待时候是同一把锁,所以不会出现死锁
      pthread_cond_broadcast(&pool->cond);
      pthread_mutex_unlock(&pool->mutex);
  
      pool->workers=NULL;
      pool->tasks=NULL;
  
      return 0;
      //
  }
  ```

   

  

  - **如何向线程池中添加一个任务**？

![image-20250907202453537](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250907202453537.png)

步骤：往任务队列里面添加一个任务，并通知柜员有人来办理任务了

signal与broadcast区别，这个是唤醒等待中的一个，而broadcast是唤醒所有





gdb调试工具：适合小工程单步调试

- 打断点方式：在有可能出现空指针的地方加上断点，while判断行、向链表中添加元素行

通过gdb调试了三个问题，b，r，c

1. pool没有进行memset，存在脏数据
2. 所传入的void *arg的类型不对导致段错误，改为传入struct nTask *task
3. 主线程没有等待任务的结束。getchar()







