# 多线程并发锁项目

## 项目背景

在火车上买火车票，比如有10个窗口去抢座位号【火车票】

关于在座位号所对应的内容，就是共享资源

什么是多线程？什么是并发执行？

```c
#include<stdio.h>
#include<pthread.h>

#define THREAD_COUNT 10

void *thread_callback(void *arg){
    int *pcount = (int *)arg;
    int i = 0;

    while(i++ < 100000){
        (*pcount)++;
        usleep(1);
    }
}
int main(){
    //线程id    
    pthread_t threadid[THREAD_COUNT] = {0};
    //每个线程都有不一样的返回函数

    int i = 0;
    //创建十个线程【十个窗口】
    int count = 0;  //十个窗口共享计数资源
    for(i = 0;i<THREAD_COUNT;i++)
    {
        pthread_create(&threadid[i],NULL,thread_callback,&count); //&count是传入到void *arg中的
    }
    for(i =0;i < 100; i++){
        printf("count: %d\n",count);
        sleep(1);
    }
}

```

有没有什么办法能够将如下三条指令变为单指令，然后就可以不加锁了？①mov [count ] ,eax; ②inc eax; ③mov eax, [count];

## 用原子操作实现

在这个问题中方案选择的优先级：原子操作>自旋锁>互斥锁

```c

#include<stdio.h>
#include<pthread.h>

#define THREAD_COUNT 10

pthread_mutex_t mutex;//mutex锁
pthread_spinlock_t spinlock;

int inc(int *value, int add){
    int old;

    __asm__ volatile(
        "lock; xaddl %0, %1;"
        : "=r"(old), "+m"(*value)   // old 是输出，*value 既是输入又是输出
        : "0"(add)                  // "0" 表示和第 0 个输出操作数复用寄存器
        : "cc", "memory"
    );
    
    
    return old;
}

void *thread_callback(void *arg){
    int *pcount = (int *)arg;
    int i = 0;

    while(i++ < 100000){
#if 0
        (*pcount)++;//
#elif 0
        pthread_mutex_lock(&mutex);
        (*pcount)++;
        pthread_mutex_unlock(&mutex);

#elif 0
        pthread_spin_lock(&spinlock);
        (*pcount)++;
        pthread_spin_unlock(&spinlock);

#else
        inc(pcount,1);
#endif
        usleep(1);
    }
}
int main(){
    //线程id    
    pthread_t threadid[THREAD_COUNT] = {0};
    //每个线程都有不一样的返回函数

    //在线程创建之前初始化加锁
    pthread_mutex_init(&mutex,NULL);
    pthread_spin_init(&spinlock,PTHREAD_PROCESS_SHARED);
    int i = 0;
    //创建十个线程【十个窗口】
    int count = 0;  //十个窗口共享计数资源
    for(i = 0;i<THREAD_COUNT;i++)
    {
        pthread_create(&threadid[i],NULL,thread_callback,&count); //&count是传入到void *arg中的
    }
    for(i =0;i < 100; i++){
        printf("count: %d\n",count);
        sleep(1);
    }
}


```





课后练习题：了解CAS，并实现CAS
