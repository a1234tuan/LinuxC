# 《软件工程》知识体系提纲

## 一、课程总体结构

| 模块 / 章节               | 作用与逻辑地位                                               |
| ------------------------- | ------------------------------------------------------------ |
| 1. 软件工程概述           | 课程入门，建立 “软件工程化” 核心认知，解释软件危机与工程化解决思路，为后续过程与方法奠定理论基础。 |
| 2. 软件生存期模型         | 定义软件开发的 “流程框架”，指导不同项目场景下的过程选择，是需求、设计、测试等阶段的前置规划依据。 |
| 3. 需求工程 & 结构化分析  | 解决 “做什么” 的问题，将用户需求转化为规范的分析模型（DFD、ER 图等），是设计与实现的直接输入。 |
| 4. 结构化设计方法         | 解决 “怎么做” 的问题（结构化视角），将需求模型转化为模块结构与过程设计，衔接需求分析与编码实现。 |
| 5. 面向对象方法 & UML     | 解决 “怎么做” 的问题（面向对象视角），通过 UML 建模描述系统静态 / 动态特征，适用于复杂系统设计。 |
| 6. 面向对象分析           | 从面向对象视角梳理需求，建立用例模型、对象模型与动态模型，为面向对象设计提供需求依据。 |
| 7. 软件体系结构与设计模式 | 提升设计层次，提供可复用的架构风格与设计方案，解决大型系统的结构组织与复杂问题优化。 |
| 8. 设计模式（补充）       | 细化面向对象设计技巧，提供通用问题的标准化解决方案，增强代码复用性与可维护性。 |

## 二、章节级知识提炼

## 第 1 章 软件工程概述

### 1️⃣ 核心知识点（Key Concepts）

- 软件的概念与特性

- 软件定义：程序 + 数据 + 文档（非单一代码）

- 软件特性：无形性、智能性、开发复杂性、维护特殊性（区别于硬件）

- 软件分类：系统软件（OS、DBMS）、支撑软件（IDE、测试工具）、应用软件（ERP、办公软件）

- 软件危机与软件工程

- 软件危机表现：成本超支、进度延误、质量低下、维护困难

- 软件工程定义：用工程化思想指导软件开发 / 维护，核心是 “结构化 + 规范化”

- 软件工程三要素：过程（框架）、方法（技术）、工具（支撑）

- 软件生命周期

- 三阶段划分：软件定义（问题定义、可行性研究、需求分析）、软件开发（设计、编码、测试）、运行维护（改正 / 适应 / 完善 / 预防性维护）

- 各阶段核心输出：需求规格说明书、设计说明书、测试报告

- 软件工程方法学

- 结构化方法：自顶向下、数据 / 功能驱动（如 SA/SD）

- 面向对象方法：对象驱动、封装 / 继承 / 多态（如 OOA/OOD）

- 形式化方法：数学建模（如形式化规格说明）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 无前置依赖（课程开篇章节）

- 后续关联：本章 “软件生命周期” 为第 2 章 “软件过程模型” 提供基础概念；“软件工程方法学” 为第 4~7 章的设计方法提供思想指导。

### 3️⃣ 学习目标（Learning Objectives）

- 能解释 “软件危机” 的表现与产生原因

- 能描述软件工程的定义、三要素及核心原则

- 能划分软件生命周期的阶段并说明各阶段任务

- 能区分结构化方法与面向对象方法的核心差异

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 1 章，梳理 “软件危机→软件工程→生命周期” 的逻辑链

1. 观看案例视频（如 “软件危机经典案例：OS/360 项目”），理解工程化的必要性

1. 对比分析：列出结构化方法与面向对象方法的 3 个关键区别

1. 实践：以 “学生选课系统” 为例，初步划分其生命周期阶段及输出物

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：能完整叙述软件生命周期三阶段的划分及各阶段核心任务；能举例说明软件工程原则（如 “分而治之”“阶段评审”）的应用。

- 自测题：

1. 简述 “软件” 与 “硬件” 在开发、维护、复用性上的 3 个核心差异。

1. 以 “手机购物 APP” 为例，说明其软件生命周期中 “需求分析” 阶段的核心任务与输出物。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《软件工程 (第 9 版) Sommerville》第 1~2 章

- 视频：B 站搜索 “软件危机 历史与教训”“软件工程三要素 讲解”

- 文档：参考 GB/T 11457-2006《软件工程术语》

## 第 2 章 软件生存期模型

### 1️⃣ 核心知识点（Key Concepts）

- 瀑布模型

- 核心逻辑：线性顺序（需求→设计→编码→测试→维护），阶段间依赖强

- 特点：推迟实现、文档驱动、阶段评审

- 适用场景：需求稳定、规模小的项目（如工具类软件）

- 迭代 / 增量模型

- 快速原型模型：先建原型验证需求，再迭代开发（抛弃型 / 演化型）

- 增量模型：分批次交付功能（如 V1.0→V2.0），每批次含 “需求 - 设计 - 测试”

- 适用场景：需求不确定、需快速交付核心功能的项目

- 螺旋模型

- 核心逻辑：“风险分析→开发→评审” 循环，每循环为一个阶段

- 特点：风险驱动、融合瀑布与原型优点

- 适用场景：大型复杂项目（如航天软件）

- 面向对象模型

- 喷泉模型：迭代 + 无间隙（分析 / 设计 / 编码重叠），面向对象开发专用

- 统一过程（UP/RUP）：四阶段（初始→细化→构造→交付）+ 迭代，用例驱动

- 敏捷模型

- 核心思想：响应变化、轻量文档、客户协作（敏捷宣言）

- 极限编程（XP）：四活动（策划→设计→编码→测试），结对编程、测试驱动

- 适用场景：需求频繁变化的项目（如互联网产品）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 1 章 “软件生命周期” 概念（阶段划分是模型设计的基础）

- 后续关联：不同模型决定后续需求分析（如敏捷模型对应快速需求获取）、设计（如瀑布模型对应结构化设计）的方法选择。

### 3️⃣ 学习目标（Learning Objectives）

- 能描述 5 种主流模型（瀑布、原型、增量、螺旋、敏捷）的核心流程

- 能分析各模型的优缺点及适用项目场景

- 能根据项目需求（如 “需求稳定的管理系统”）选择合适的开发模型

- 能解释 UP 模型的四阶段与 XP 的核心实践（如结对编程）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 2 章，绘制各模型的流程示意图（标注关键阶段）

1. 案例分析：对比 “政务 OA 系统” 与 “短视频 APP” 适合的开发模型及原因

1. 工具学习：用 Visio 绘制螺旋模型的 “风险分析→开发” 循环图

1. 小组讨论：分析 “敏捷模型是否适合大型银行核心系统” 并给出理由

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：能清晰区分 “瀑布模型” 与 “增量模型” 的交付方式差异；能列举 XP 的 3 个核心实践并说明其价值。

- 自测题：

1. 某公司需开发 “员工考勤系统”（需求明确，功能固定），请选择合适的开发模型并说明理由。

1. 简述 “螺旋模型” 中 “风险分析” 阶段的核心任务，并举 1 个该阶段需规避的典型风险（如技术风险）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《软件工程与实践》第 3 章

- 视频：B 站搜索 “UP 统一过程 四阶段讲解”“XP 极限编程 实践案例”

- 工具：使用 ProcessOn 绘制各模型的流程图

## 第 3 章 需求工程 & 结构化分析

### 1️⃣ 核心知识点（Key Concepts）

- 需求工程基础

- 需求层次：业务需求（为什么做）→用户需求（用户要什么）→功能需求（系统做什么）

- 需求工程流程：需求获取→分析→定义→验证

- 关键术语：需求规格说明书（SRS）、数据需求说明（DRD）

- 需求获取方法

- 调研方法：用户访谈、问卷调查、现场观察、场景分析

- 业务建模：系统流程图（SFD）→描述信息在系统内的流动（区别于程序流程图）

- 结构化分析（SA）

- 功能建模：数据流图（DFD）

- 元素：外部实体、加工、数据流、数据存储

- 分层：顶层 DFD（环境图）→一层 DFD→二层 DFD（细化加工）

- 数据建模：实体 - 关系图（ER 图）

- 元素：实体（矩形）、属性（椭圆）、关系（菱形，1:1/1:n/m:n）

- 行为建模：状态转换图→描述对象状态及触发事件

- 数据字典与加工规格说明

- 数据字典：定义 DFD 中所有元素（数据流、数据存储等），如 “学号 = 8 位整数”

- 加工规格：描述基本加工逻辑（决策表、决策树、结构化英语）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 2 章 “开发模型”（如瀑布模型需完整 SRS，敏捷模型需快速需求清单）

- 后续关联：DFD/ER 图是第 4 章 “结构化设计” 的输入；SRS 是后续设计、测试的依据。

### 3️⃣ 学习目标（Learning Objectives）

- 能使用访谈 / 问卷法获取用户需求并整理为需求清单

- 能绘制分层 DFD 图（含顶层、一层）并说明数据流逻辑

- 能绘制 ER 图并表示实体间的 1:n/m:n 关系

- 能使用决策表描述复杂加工逻辑（如 “订单审批规则”）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 3 章，掌握 DFD/ER 图的符号规范

1. 工具实践：用 Visio 绘制 “图书借阅系统” 的顶层 DFD（外部实体：读者、管理员；加工：借阅处理；数据流：借阅请求、借阅记录）

1. 案例分析：根据 “学生成绩管理系统” 需求，绘制 ER 图（实体：学生、课程、成绩；关系：选课）

1. 编写实践：为 “购物订单折扣规则”（满 100 减 20，会员额外 9 折）编写决策表

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：DFD 图无语法错误（如数据流必须连接加工）；ER 图能正确表示多对多关系（如学生 - 选课 - 课程）；决策表无冗余规则。

- 自测题：

1. 绘制 “ATM 取款系统” 的顶层 DFD，标注外部实体、加工、数据流（至少含 “插卡→验证→取款→吐钞” 流程）。

1. 某电商系统中，“用户” 可下多个 “订单”，一个 “订单” 含多个 “商品”，请绘制 ER 图并标注关系类型。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《软件工程 (第 9 版) Sommerville》第 4~5 章

- 工具：Visio、PowerDesigner（绘制 DFD/ER 图）

- 视频：B 站搜索 “数据流图 DFD 分层绘制教程”“ER 图 多对多关系讲解”

## 第 4 章 结构化设计方法

### 1️⃣ 核心知识点（Key Concepts）

- 软件设计基础

- 设计原则：分而治之、模块独立性（高内聚、低耦合）、信息隐藏

- 模块独立性指标：

- 耦合：模块间依赖程度（内容耦合 > 公共耦合 > 控制耦合 > 数据耦合，推荐数据耦合）

- 内聚：模块内功能相关性（功能内聚 > 顺序内聚 > 通信内聚 > 过程内聚 > 逻辑内聚 > 偶然内聚，推荐功能内聚）

- 结构化设计（SD）

- 体系结构设计：将 DFD 转化为结构图（SC）

- 变换型映射：DFD 的 “输入→变换→输出” 对应 SC 的 “输入模块→变换模块→输出模块”

- 事务型映射：DFD 的 “事务中心→分支” 对应 SC 的 “事务模块→子事务模块”

- 模块结构表示：结构图（SC）→模块（矩形）、调用关系（箭头）、条件调用（菱形）、循环调用（弧形）

- 详细设计

- 过程设计工具：程序流程图、N-S 图、PAD 图、伪代码

- 结构化程序设计：仅用 3 种控制结构（顺序、选择、循环），单入口 / 单出口

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 3 章 “结构化分析”（DFD 是变换 / 事务映射的输入）

- 后续关联：结构图（SC）是编码阶段的模块划分依据；过程设计工具（如伪代码）可直接指导编码。

### 3️⃣ 学习目标（Learning Objectives）

- 能解释 “高内聚、低耦合” 的含义及对软件质量的影响

- 能区分 5 种耦合类型与 6 种内聚类型并判断模块独立性

- 能将简单 DFD 图（如 “成绩录入系统”）转化为结构图（SC）

- 能使用 N-S 图 / PAD 图描述模块的过程逻辑（如 “成绩排名”）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 4 章，整理 “耦合 / 内聚” 的类型及判断标准

1. 案例分析：判断 “用户登录模块” 与 “数据库操作模块” 的耦合类型（如数据耦合）

1. 工具实践：根据 “图书借阅 DFD”，用 Visio 绘制变换型结构图

1. 编程预备：用伪代码描述 “学生成绩排序” 模块的逻辑（含冒泡排序）

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：能准确判断模块的耦合 / 内聚类型；能将 DFD 的加工正确映射为 SC 的模块；N-S 图无跳转（符合结构化设计）。

- 自测题：

1. 某模块 “读取用户输入→验证格式→查询数据库→返回结果”，判断其最可能的内聚类型并说明理由。

1. 根据以下 DFD 片段（加工 “计算折扣” 输入 “订单金额”，输出 “折扣金额”），绘制对应的模块结构图（含输入、变换、输出模块）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《软件工程与实践》第 6 章

- 工具：Visio（绘制 SC 图）、ProcessOn（绘制 N-S 图）

- 视频：B 站搜索 “模块独立性 耦合与内聚讲解”“变换型映射 实例”

## 第 5 章 面向对象方法 & UML

### 1️⃣ 核心知识点（Key Concepts）

- 面向对象（OO）基础

- 核心概念：对象（数据 + 操作，如 Student 对象）、类（对象抽象，如 Student 类）、封装（信息隐蔽）、继承（子类继承父类，如 Undergraduate→Student）、多态（同一方法不同实现，如 draw () 在 Circle/Square 中的差异）

- 关键术语：消息（对象间通信，如 student1.changeAddress ()）、UML（统一建模语言，OMG 标准）

- UML 基础

- UML 事物：结构事物（类、对象、用例、构件）、行为事物（交互、状态机）、分组事物（包）、注释事物（注释）

- UML 关系：依赖（虚线箭头，如 A 依赖 B）、关联（直线，含聚合 / 组合）、泛化（空心三角箭头，如子类→父类）、实现（虚线空心三角，如类→接口）

- 易混淆：聚合（弱整体 - 部分，如剧组 - 演员）vs 组合（强整体 - 部分，如窗口 - 按钮）

- UML 图

- 静态图：类图（描述类及关系）、对象图（类的实例）、构件图（物理构件）、部署图（硬件拓扑）

- 动态图：用例图（参与者 + 用例，如 “学生 - 选课”）、顺序图（时间顺序交互）、通信图（对象间链接）、状态图（对象状态变迁）、活动图（流程步骤，含泳道）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 1 章 “面向对象方法学” 概念、第 3 章 “需求分析”（用例图基于需求）

- 后续关联：UML 图（如类图）是第 6 章 “面向对象分析”、第 7 章 “设计模式” 的核心建模工具。

### 3️⃣ 学习目标（Learning Objectives）

- 能解释面向对象的 5 个核心概念（对象、类、封装、继承、多态）

- 能区分 UML 的 4 种关系（依赖、关联、泛化、实现）并绘制类图

- 能绘制用例图并表示用例间关系（包含、扩展、泛化）

- 能绘制顺序图描述对象间的消息交互（如 “用户登录” 流程）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 5 章，整理 UML 各类图的适用场景（如用例图→需求建模，类图→静态结构）

1. 工具实践：用 Enterprise Architect（EA）绘制 “学生选课系统” 类图（类：Student、Course；属性：studentNo、courseName；关系：选课，m:n）

1. 案例分析：绘制 “网上购物” 用例图（参与者：用户、商家；用例：浏览商品、下单、支付；关系：支付包含 “验证支付密码”）

1. 动态建模：用 EA 绘制 “用户下单” 顺序图（对象：User、Order、Payment；消息：createOrder ()、verifyPayment ()）

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：类图能正确表示继承 / 关联关系；用例图无多余参与者（如 “数据库” 不属参与者）；顺序图能体现消息发送顺序。

- 自测题：

1. 绘制 “图书馆管理系统” 的类图，包含类 “Book”“Reader”“BorrowRecord”，标注属性、方法及类间关系。

1. 绘制 “用户注册” 顺序图，描述用户（User）、注册模块（RegisterModule）、数据库（DB）之间的消息交互（至少含 “提交注册信息→验证用户名→保存数据”）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《UML 用户指南》第 3~5 章

- 工具：Enterprise Architect（EA）、StarUML

- 视频：B 站搜索 “UML 类图 聚合 vs 组合”“UML 顺序图 实例教程”

## 第 6 章 面向对象分析

### 1️⃣ 核心知识点（Key Concepts）

- 面向对象分析（OOA）基础

- OOA 目标：建立问题域模型（用例模型、对象模型、动态模型）

- 系统边界：划分系统与外部实体的界限（如 “选课系统” 边界内不含 “学籍档案系统”）

- 用例模型构建

- 参与者识别：人员（学生）、外部系统（学籍档案系统）、设备（打印机）

- 用例提取：从参与者需求中识别功能（如 “学生 - 选课”“教师 - 提交成绩”）

- 用例规格说明：包含前置条件、后置条件、主事件流、备选事件流

- 对象模型构建

- 类 / 对象识别：从问题域中提取（如 “选课系统” 中的 Student、Course）

- 类结构：泛化（如 Graduate→Student）、关联（如 Student-Course 的选课关系）

- 属性与服务：属性（描述状态，如 studentNo）、服务（描述行为，如 calculateScore ()）

- 动态模型构建

- 顺序图：按时间顺序描述对象交互（如 “选课” 中 Student→CourseTask→ArchiveSystem 的消息）

- 状态图：描述对象状态变迁（如 CourseTask 的 “可选→人满→关闭”）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 3 章 “需求获取”（参与者 / 用例源于需求）、第 5 章 “UML”（用例图 / 类图 / 顺序图是 OOA 的建模工具）

- 后续关联：OOA 的 3 个模型是第 7 章 “面向对象设计” 的直接输入（如对象模型→设计类结构）。

### 3️⃣ 学习目标（Learning Objectives）

- 能识别系统的参与者与用例并绘制用例图

- 能编写用例规格说明（含主事件流与备选事件流）

- 能从问题域中提取类 / 对象并构建对象模型（类图）

- 能绘制顺序图与状态图描述系统动态行为

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 6 章，掌握 OOA 三模型的构建步骤

1. 案例实践：以 “在线考试系统” 为例，识别参与者（考生、监考员）与用例（登录、答题、阅卷）

1. 文档编写：编写 “考生答题” 用例的规格说明（前置条件：考生登录；主事件流：进入题库→答题→提交）

1. 建模实践：用 EA 绘制 “在线考试系统” 的类图（类：Exam、Question、Examinee）及 “提交试卷” 顺序图

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：用例无遗漏核心功能；类图能覆盖问题域关键实体；顺序图能完整描述一次交互流程。

- 自测题：

1. 以 “外卖订餐系统” 为例，列出 3 个参与者及对应的用例（每个参与者至少 2 个用例）。

1. 编写 “用户下单” 用例的主事件流（步骤：浏览商家→选择商品→提交订单→支付）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《面向对象分析与设计》第 4~6 章

- 工具：Enterprise Architect（EA）

- 视频：B 站搜索 “面向对象分析 用例建模”“OOA 对象模型构建 实例”

## 第 7 章 软件体系结构与设计模式

### 1️⃣ 核心知识点（Key Concepts）

- 软件体系结构基础

- 体系结构定义：系统构件、连接件及约束的集合（如 Bass 定义）

- 体系结构风格：

- 数据流风格：管道 - 过滤器（如编译器）、批处理

- 调用 / 返回风格：主程序 - 子程序、层次结构（如 OS 分层）、面向对象

- 仓库风格：数据库系统、黑板系统（如语音识别）

- 分布式系统结构

- C/S 结构：客户机 + 服务器（如桌面应用），分瘦客户 / 胖客户

- B/S 结构：浏览器 + Web 服务器 + 数据库服务器（如网页应用）

- 分布式对象：CORBA、J2EE（构件通过中间件通信）

- 设计模式

- 模式分类：创建型（工厂方法、单例）、结构型（适配器、装饰器）、行为型（观察者、策略）

- 核心模式：

- 单例模式：确保类仅一个实例（如配置类）

- 工厂方法模式：定义创建接口，子类决定实例化（如 CarFactory→BenzFactory）

- 观察者模式：一对多依赖，状态变化通知（如 GUI 按钮 - 事件监听）

- 适配器模式：转换接口（如类适配器、对象适配器）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 4 章 “结构化设计”（模块结构）、第 5 章 “UML”（类图描述模式结构）、第 6 章 “OOA”（对象模型）

- 后续关联：体系结构风格指导系统整体设计；设计模式指导代码级实现（如单例模式用于配置管理）。

### 3️⃣ 学习目标（Learning Objectives）

- 能描述 3 种体系结构风格（如管道 - 过滤器、C/S）的核心逻辑与适用场景

- 能区分 C/S 与 B/S 结构的差异及适用项目

- 能解释 5 种核心设计模式（单例、工厂方法、观察者、适配器、装饰器）的意图与结构

- 能在代码中应用单例模式（如 Java 实现）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 7 章，整理体系结构风格的特点与案例

1. 案例分析：对比 “微信客户端”（C/S）与 “在线文档”（B/S）的结构差异

1. 模式学习：绘制单例模式的类图（含私有构造、静态实例、getInstance ()）

1. 代码实践：用 Java 实现单例模式（饿汉式 / 懒汉式）

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：能准确选择体系结构风格（如 “编译器” 选管道 - 过滤器）；能绘制设计模式类图；能写出单例模式核心代码。

- 自测题：

1. 某公司需开发 “企业 ERP 系统”（需本地处理大量数据），选择 C/S 还是 B/S 结构并说明理由。

1. 用 Java 实现懒汉式单例模式（含 synchronized 关键字保证线程安全）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《设计模式：可复用面向对象软件的基础》（Gamma 等）第 1~3 章

- 视频：B 站搜索 “软件体系结构风格 案例讲解”“设计模式 单例模式 代码实现”

- 代码：GitHub 搜索 “design-patterns-java”（设计模式代码示例）

## 第 8 章 设计模式（补充）

### 1️⃣ 核心知识点（Key Concepts）

- 设计模式原则

- 开闭原则：对扩展开放，对修改关闭（如用接口实现扩展）

- 里氏代换原则：子类可替换父类（如 Rectangle→Shape）

- 依赖倒置原则：依赖抽象，不依赖具体（如依赖 Interface 而非 Class）

- 模式细化

- 创建型：抽象工厂（产品族创建，如 WindowsFactory→Button/Text）、建造者（复杂对象构建，如 Builder→Director）

- 结构型：组合模式（树形结构，如 Component→Leaf/Composite）、代理模式（控制访问，如 RemoteProxy）

- 行为型：策略模式（算法替换，如 SortStrategy→BubbleSort）、责任链模式（请求链式传递，如 Handler→ConcreteHandler）

### 2️⃣ 前置依赖与关联关系（Knowledge Dependencies）

- 前置依赖：第 5 章 “面向对象”（封装 / 继承 / 多态是模式基础）、第 7 章 “设计模式基础”

- 后续关联：设计模式直接指导编码实现（如组合模式用于文件系统设计）。

### 3️⃣ 学习目标（Learning Objectives）

- 能解释 5 个设计模式原则的含义及应用场景

- 能区分抽象工厂与工厂方法模式的差异

- 能绘制组合模式 / 策略模式的类图

- 能在项目中选择合适的模式解决问题（如 “文件系统” 用组合模式）

### 4️⃣ 推荐学习路径（Learning Path）

1. 阅读 PPT 第 8 章，整理各模式的适用场景对比表

1. 案例分析：分析 “日志系统”（控制台日志 / 文件日志）适合的模式（如策略模式）

1. 建模实践：绘制组合模式类图（Component：File；Leaf：TextFile；Composite：Folder）

1. 代码实践：用 Java 实现策略模式（排序策略：冒泡 / 快速排序）

### 5️⃣ 达成标准与自我检测（Mastery Criteria & Self-test）

- 达成标准：能准确判断模式适用场景；类图符合模式结构；代码能体现模式核心逻辑（如策略模式的算法替换）。

- 自测题：

1. 简述 “抽象工厂模式” 与 “工厂方法模式” 的核心差异（从产品范围角度）。

1. 用组合模式设计 “文件系统”，写出 Component、Leaf（TextFile）、Composite（Folder）的核心方法（如 add ()、delete ()）。

### 6️⃣ 推荐资源方向（Optional）

- 教材：《设计模式：可复用面向对象软件的基础》第 4~6 章

- 视频：B 站搜索 “抽象工厂模式 实例”“组合模式 文件系统设计”

- 工具：DrawIO（绘制模式类图）

## 三、知识结构图建议

```
软件工程
├── 1. 软件工程概述
│   ├── 软件的概念与特性
│   │   ├── 软件定义（程序+数据+文档）
│   │   ├── 软件特性（无形性、智能性）
│   │   └── 软件分类（系统/支撑/应用）
│   ├── 软件危机与软件工程
│   │   ├── 软件危机表现（成本/进度/质量）
│   │   ├── 软件工程定义与三要素（过程/方法/工具）
│   │   └── 软件工程原则（分而治之、阶段评审）
│   └── 软件生命周期与方法学
│       ├── 生命周期三阶段（定义/开发/维护）
│       └── 方法学（结构化/面向对象/形式化）
├── 2. 软件生存期模型
│   ├── 线性模型（瀑布模型）
│   ├── 迭代/增量模型（原型/增量）
│   ├── 风险驱动模型（螺旋模型）
│   ├── 面向对象模型（喷泉/UP）
│   └── 敏捷模型（XP/ASD）
├── 3. 需求工程&结构化分析
│   ├── 需求工程基础
│   │   ├── 需求层次（业务/用户/功能）
│   │   └── 需求流程（获取/分析/定义/验证）
│   ├── 结构化分析（SA）
│   │   ├── 功能建模（DFD图）
│   │   ├── 数据建模（ER图）
│   │   └── 行为建模（状态图）
│   └── 规格说明（数据字典/加工规格）
├── 4. 结构化设计方法
│   ├── 设计原则（分而治之、模块独立性）
│   ├── 模块独立性（耦合/内聚）
│   ├── 体系结构设计（变换/事务映射）
│   └── 详细设计（程序流程图/N-S图/伪代码）
├── 5. 面向对象方法&UML
│   ├── 面向对象核心概念（对象/类/封装/继承/多态）
│   ├── UML基础（事物/关系）
│   └── UML图（用例图/类图/顺序图/状态图）
├── 6. 面向对象分析（OOA）
│   ├── 用例模型（参与者/用例/规格说明）
│   ├── 对象模型（类/属性/服务/关系）
│   └── 动态模型（顺序图/状态图）
├── 7. 软件体系结构与设计模式
│   ├── 体系结构基础（定义/风格）
│   ├── 分布式结构（C/S/B/S/分布式对象）
│   └── 设计模式（创建型/结构型/行为型）
└── 8. 设计模式（补充）
    ├── 设计模式原则（开闭/里氏代换/依赖倒置）
    ├── 创建型模式（抽象工厂/建造者）
    ├── 结构型模式（组合/代理）
    └── 行为型模式（策略/责任链）
```

## 四、补充说明

⚠️ 本课程 PPT 未覆盖 “软件测试”“软件维护”“项目管理”（进度 / 成本 / 质量）等核心模块，建议补充学习：

- 软件测试：黑盒测试（等价类 / 边界值）、白盒测试（语句覆盖 / 分支覆盖）、测试流程（单元测试→集成测试→系统测试）

- 软件维护：维护分类（改正 / 适应 / 完善 / 预防性）、维护成本与质量

- 项目管理：甘特图（进度计划）、风险管理、质量保证（QA）

推荐补充资源：《软件工程 (第 9 版) Sommerville》第 7~9 章、第 11 章；B 站搜索 “软件测试 黑盒测试方法”“项目管理 甘特图教程”。